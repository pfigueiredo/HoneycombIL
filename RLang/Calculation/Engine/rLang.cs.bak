//Generated by the GOLD Parser Builder
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Text.RegularExpressions;

namespace RLang.Calculation.Engine {

    public enum ParserBackend {
        IL, //Compiled to IL with System.Reflection.Emit
        EXEC, //Execution with System.Link.Expressions
        PARSE //Just parse and generate the expression tree
    }

    public class rLangParser {
        private GOLD.Parser parser = new GOLD.Parser();

        private enum SymbolIndex {
            @Eof = 0,                                  // (EOF)
            @Error = 1,                                // (Error)
            @Comment = 2,                              // Comment
            @Newline = 3,                              // NewLine
            @Whitespace = 4,                           // Whitespace
            @Timesdiv = 5,                             // '*/'
            @Divtimes = 6,                             // '/*'
            @Divdiv = 7,                               // '//'
            @Minus = 8,                                // '-'
            @Dollar = 9,                               // '$'
            @Dollardollar = 10,                        // '$$'
            @Percent = 11,                             // '%'
            @Amp = 12,                                 // '&'
            @Lparen = 13,                              // '('
            @Rparen = 14,                              // ')'
            @Times = 15,                               // '*'
            @Comma = 16,                               // ','
            @Div = 17,                                 // '/'
            @Colon = 18,                               // ':'
            @At = 19,                                  // '@'
            @Lbracket = 20,                            // '['
            @Rbracket = 21,                            // ']'
            @Caret = 22,                               // '^'
            @Lbrace = 23,                              // '{'
            @Rbrace = 24,                              // '}'
            @Plus = 25,                                // '+'
            @Lt = 26,                                  // '<'
            @Lteq = 27,                                // '<='
            @Ltgt = 28,                                // '<>'
            @Eq = 29,                                  // '='
            @Gt = 30,                                  // '>'
            @Gteq = 31,                                // '>='
            @And = 32,                                 // AND
            @Else = 33,                                // ELSE
            @End = 34,                                 // END
            @Identifier = 35,                          // Identifier
            @If = 36,                                  // IF
            @Not = 37,                                 // NOT
            @Number = 38,                              // Number
            @Or = 39,                                  // OR
            @Stringliteral = 40,                       // StringLiteral
            @Then = 41,                                // THEN
            @Addexp = 42,                              // <Add Exp>
            @Args = 43,                                // <Args>
            @Assignexp = 44,                           // <Assign Exp>
            @Assignlist = 45,                          // <AssignList>
            @Boolexp = 46,                             // <Bool Exp>
        @Colreference = 47,                        // <ColReference>
        @Expression = 48,                          // <Expression>
        @Identexpression = 49,                     // <IdentExpression>
        @Multexp = 50,                             // <Mult Exp>
        @Negateexp = 51,                           // <Negate Exp>
        @Percentexp = 52,                          // <Percent Exp>
        @Powexp = 53,                              // <Pow Exp>
        @Program = 54,                             // <Program>
        @Value = 55                                // <Value>
        }

    private enum ProductionIndex {

        @Program = 0,                              // <Program> ::= <AssignList>
        @Program_Eq = 1,                           // <Program> ::= '=' <Bool Exp>
        @Assignlist = 2,                           // <AssignList> ::= <AssignList> <Assign Exp>
        @Assignlist2 = 3,                          // <AssignList> ::= <Assign Exp>
        @Assignexp_Eq_Lbrace_Rbrace = 4,           // <Assign Exp> ::= <IdentExpression> '=' '{' <Bool Exp> '}'
        @Assignexp_At_Eq_Lbrace_Rbrace = 5,        // <Assign Exp> ::= '@' <IdentExpression> '=' '{' <Bool Exp> '}'
        @Assignexp_Dollardollar_Eq_Lbrace_Rbrace = 6,  // <Assign Exp> ::= '$$' <IdentExpression> '=' '{' <Bool Exp> '}'
        @Assignexp_Dollar_Eq_Lbrace_Rbrace = 7,    // <Assign Exp> ::= '$' <IdentExpression> '=' '{' <Bool Exp> '}'
        @Assignexp_Dollar_Lbracket_Colon_Rbracket_Eq_Lbrace_Rbrace = 8,  // <Assign Exp> ::= '$' <IdentExpression> '[' <ColReference> ':' <ColReference> ']' '=' '{' <Bool Exp> '}'
        @Assignexp_Dollar_Lbracket_Rbracket_Eq_Lbrace_Rbrace = 9,  // <Assign Exp> ::= '$' <IdentExpression> '[' <ColReference> ']' '=' '{' <Bool Exp> '}'
        @Args_Comma = 10,                          // <Args> ::= <Args> ',' <Bool Exp>
        @Args = 11,                                // <Args> ::= <Bool Exp>
        @Boolexp_And = 12,                         // <Bool Exp> ::= <Bool Exp> AND <Expression>
        @Boolexp_Or = 13,                          // <Bool Exp> ::= <Bool Exp> OR <Expression>
        @Boolexp_And_Lparen_Rparen = 14,           // <Bool Exp> ::= AND '(' <Args> ')'
        @Boolexp_Or_Lparen_Rparen = 15,            // <Bool Exp> ::= OR '(' <Args> ')'
        @Boolexp_Not = 16,                         // <Bool Exp> ::= NOT <Expression>
        @Boolexp = 17,                             // <Bool Exp> ::= <Expression>
        @Expression_Gt = 18,                       // <Expression> ::= <Expression> '>' <Add Exp>
        @Expression_Lt = 19,                       // <Expression> ::= <Expression> '<' <Add Exp>
        @Expression_Lteq = 20,                     // <Expression> ::= <Expression> '<=' <Add Exp>
        @Expression_Gteq = 21,                     // <Expression> ::= <Expression> '>=' <Add Exp>
        @Expression_Eq = 22,                       // <Expression> ::= <Expression> '=' <Add Exp>
        @Expression_Ltgt = 23,                     // <Expression> ::= <Expression> '<>' <Add Exp>
        @Expression = 24,                          // <Expression> ::= <Add Exp>
        @Addexp_Plus = 25,                         // <Add Exp> ::= <Add Exp> '+' <Mult Exp>
        @Addexp_Minus = 26,                        // <Add Exp> ::= <Add Exp> '-' <Mult Exp>
        @Addexp_Amp = 27,                          // <Add Exp> ::= <Add Exp> '&' <Mult Exp>
        @Addexp = 28,                              // <Add Exp> ::= <Mult Exp>
        @Multexp_Times = 29,                       // <Mult Exp> ::= <Mult Exp> '*' <Pow Exp>
        @Multexp_Div = 30,                         // <Mult Exp> ::= <Mult Exp> '/' <Pow Exp>
        @Multexp = 31,                             // <Mult Exp> ::= <Pow Exp>
        @Powexp_Caret = 32,                        // <Pow Exp> ::= <Pow Exp> '^' <Percent Exp>
        @Powexp = 33,                              // <Pow Exp> ::= <Percent Exp>
        @Percentexp_Percent = 34,                  // <Percent Exp> ::= <Negate Exp> '%'
        @Percentexp = 35,                          // <Percent Exp> ::= <Negate Exp>
        @Negateexp_Minus = 36,                     // <Negate Exp> ::= '-' <Value>
        @Negateexp = 37,                           // <Negate Exp> ::= <Value>
        @Value_Number = 38,                        // <Value> ::= Number
        @Value_If_Lparen_Rparen_Then_End = 39,     // <Value> ::= IF '(' <Bool Exp> ')' THEN <Bool Exp> END
        @Value_If_Lparen_Rparen_Then_Else_End = 40,  // <Value> ::= IF '(' <Bool Exp> ')' THEN <Bool Exp> ELSE <Bool Exp> END
        @Value_If_Lparen_Rparen = 41,              // <Value> ::= IF '(' <Args> ')'
        @Value_Lparen_Rparen = 42,                 // <Value> ::= <IdentExpression> '(' <Args> ')'
        @Value_Lparen_Rparen2 = 43,                // <Value> ::= <IdentExpression> '(' ')'
        @Value_Dollar_Lbracket_Rbracket_Colon_Dollar_Lbracket_Rbracket = 44,  // <Value> ::= '$' <IdentExpression> '[' <ColReference> ']' ':' '$' <IdentExpression> '[' <ColReference> ']'
        @Value_Dollar_Lbracket_Colon_Rbracket = 45,  // <Value> ::= '$' <IdentExpression> '[' <ColReference> ':' <ColReference> ']'
        @Value_Dollar_Lbracket_Rbracket = 46,      // <Value> ::= '$' <IdentExpression> '[' <ColReference> ']'
        @Value_Lbracket_Rbracket_Colon_Identifier_Lbracket_Rbracket = 47,  // <Value> ::= <IdentExpression> '[' <ColReference> ']' ':' Identifier '[' <ColReference> ']'
        @Value_Lbracket_Colon_Rbracket = 48,       // <Value> ::= <IdentExpression> '[' <ColReference> ':' <ColReference> ']'
        @Value_Lbracket_Rbracket = 49,             // <Value> ::= <IdentExpression> '[' <ColReference> ']'
        @Value_Dollar_Identifier_Colon_Dollar_Identifier = 50,  // <Value> ::= '$' Identifier ':' '$' Identifier
        @Value_Dollar_Identifier_Dollar_Number_Colon_Dollar_Identifier_Dollar_Number = 51,  // <Value> ::= '$' Identifier '$' Number ':' '$' Identifier '$' Number
        @Value_Dollar = 52,                        // <Value> ::= '$' <IdentExpression>
        @Value_Dollardollar = 53,                  // <Value> ::= '$$' <IdentExpression>
        @Value_At = 54,                            // <Value> ::= '@' <IdentExpression>
        @Value = 55,                               // <Value> ::= <IdentExpression>
        @Value_Stringliteral = 56,                 // <Value> ::= StringLiteral
        @Value_Lparen_Rparen3 = 57,                // <Value> ::= '(' <Bool Exp> ')'
        @Identexpression_Identifier = 58,          // <IdentExpression> ::= Identifier
        @Colreference_Number = 59,                 // <ColReference> ::= Number
        @Colreference_Minus_Number = 60,           // <ColReference> ::= '-' Number
        @Colreference_Dollar_Number = 61           // <ColReference> ::= '$' Number

    }

        private SymbolTable globalSymbolTable;
        private int lastLine = 0;
        private int lastColumn = 0;
        private GOLD.Token lastToken = null;

        public bool SaveAssembly { get; set; }

        public SymbolTable GlobalSymbolTable { get { return globalSymbolTable; } }

        public void Setup() {
            var resourceName = "RLang.Calculation.Engine.rLang.egt";
            Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName);

            string[] names = Assembly.GetExecutingAssembly().GetManifestResourceNames();

            try {
                BinaryReader bReader = new BinaryReader(stream);
                parser.LoadTables(bReader);
            } catch {
                //Will throw on Parse
            }
        }

        public class Result {
            public ParserBackend ResultType { get; set; }
            public ExecutionContext ExecutionContext { get; set; }
            public string DebugView { get; set; }
            public AssemblyBuilder Assembly { get; set; }
            public string Filename { get; set; }
            public Type Main { get; set; } 
            public object Value { get; set; }
        }

        public rLangParser.Result Parse(
            string source,
            ParserBackend backend
        ) {
            return Parse(source, backend, null, null);
        }

        public rLangParser.Result Parse(
            string source,
            ParserBackend backend,
            Dictionary<string, MethodInfo> builtInMethods
        ) {
            return Parse(source, backend, null, builtInMethods);
        }

        public rLangParser.Result Parse(
            string source,
            ParserBackend backend,
            ExecutionContext context,
            Dictionary<string, MethodInfo> builtInMethods
        ) {

            if (backend != ParserBackend.IL 
                && backend != ParserBackend.PARSE
                && backend != ParserBackend.EXEC)
                throw new NotImplementedException(
                    string.Format("The only implemented backends are 'PARSE', 'IL' and 'EXEC'. '{0}' is not an option for me at this stage --PF", backend)
                );

            TextReader reader = new StringReader(source);

            GOLD.ParseMessage response;
            bool done;                      
            bool accepted = false;          

            parser.Open(reader);
            parser.TrimReductions = false;   

            object program = null;

            done = false;
            while (!done) {
                response = parser.Parse();

                var position = parser.CurrentPosition();
                this.lastLine = position.Line;
                this.lastColumn = position.Column;
                this.lastToken = parser.CurrentToken();

                switch (response) {
                    case GOLD.ParseMessage.LexicalError:
                        done = true; accepted = false;
                        throw new LexicalErrorException(new LexicalError(this.lastLine, this.lastColumn, this.lastToken.Data.ToString()));
                    case GOLD.ParseMessage.SyntaxError:
                        done = true; accepted = false;
                        throw new SyntaxErrorException(new SyntaxError(
                            this.lastLine, this.lastColumn,
                            this.lastToken.Data.ToString(),
                            this.parser.ExpectedSymbols().Text()
                        ));
                    case GOLD.ParseMessage.Reduction:
                        //I Have to implement this if i want to be able to parse large expressions 
                        //and to avoid stack overflow when going deep into the parse tree, but there is
                        //no need to do this as i'm not expecting to receive 1k+ expressions --PF
                        break;

                    case GOLD.ParseMessage.Accept:
                        //Accepted, lets go an make some IL out of this!
                        program = parser.CurrentReduction;  //The root node!
                        done = true;
                        accepted = true;
                        break;

                    case GOLD.ParseMessage.TokenRead:
                        break;

                    case GOLD.ParseMessage.InternalError:
                        done = true;
                        throw new Exception("Internal Parser Error"); //this is not good... 

                    case GOLD.ParseMessage.NotLoadedError:
                        done = true;
                        throw new Exception("Language tables not loaded"); //:P

                    case GOLD.ParseMessage.GroupError:
                        //GROUP ERROR! Unexpected end of file... blablabla near EOF :D
                        done = true;
                        done = true; accepted = false;
                        throw new SyntaxErrorException(new SyntaxError(
                            this.lastLine, this.lastColumn,
                            this.lastToken.Data.ToString(),
                            this.parser.ExpectedSymbols().Text()
                        ));
                }
            } //while

            rLangParser.Result result = new Result();

            //the question is: how can i every accept a null program? 
            //always check it bacause there are no one way streets.
            if (accepted && program != null) {

                this.globalSymbolTable = new SymbolTable(builtInMethods);
                context = (context != null) ? context : new ExecutionContext();

                SymbolTable localSymbolTabel = this.globalSymbolTable.CreateLocalSymbolTable();

                var exp = CreateObject(program as GOLD.Reduction, localSymbolTabel) as rLangExpression;

                if ((exp as AssignExpression) == null) {

                    AssignExpression aExp = new AssignExpression(
                        localSymbolTabel.GetSymbol("Result", IdentifierSymbolType.GlobalVariable, 0, 0),
                        exp, localSymbolTabel
                    );

                    exp = aExp;
                }

                //When only a few of us are left, we will feel an irresistible 
                //pull towards a far away land, to fight for the Prize 
                //now lets IL this baby!

                if (backend == ParserBackend.EXEC || backend == ParserBackend.IL) {

                    List<Expression> eList = new List<Expression>();
                    List<ParameterExpression> pExpressions = new List<ParameterExpression>();
                    var ctxParam = Expression.Parameter(typeof(ExecutionContext), "__context");

                    var ret = rLangExpression.CreateLinkExpressionTree(exp, ExpressionType.ANY, eList, pExpressions, ctxParam);

                    //pExpressions.Add(ctxParam);

                    foreach (var s in localSymbolTabel.Symbols) {
                        if (s.IdentifierType == IdentifierSymbolType.Variable && s.LinqExpression != null)
                            pExpressions.Add((ParameterExpression)s.LinqExpression);
                    }

                    BlockExpression block = Expression.Block(pExpressions.ToArray(), eList.ToArray());
                    
                    var l = Expression.Lambda(block, ctxParam);

                    if (backend == ParserBackend.EXEC) {
                        result.ExecutionContext = context;
                        var cExpression = l.Compile();

                        while (context != null) {
                            try {
                                result.Value = cExpression.DynamicInvoke(context);
                                context = context.Next;
                            } catch (TargetInvocationException ex) {
                                if (ex.InnerException != null)
                                    throw ex.InnerException;
                            }
                        }
                    } else if (backend == ParserBackend.IL) {
                        AssemblyName an = new AssemblyName();
                        an.Name = string.Format("rLang{0}", System.Guid.NewGuid().ToString().Replace("-", ""));
                        AppDomain ad = AppDomain.CurrentDomain;
                        AssemblyBuilder ab = ad.DefineDynamicAssembly(an, AssemblyBuilderAccess.RunAndSave, Path.GetTempPath());

                        ab.DefineVersionInfoResource("rLand", "1.2", "", "2016:54334B", "");
                        result.Filename = string.Format("{0}.dll", an.Name);

                        ModuleBuilder mb = ab.DefineDynamicModule(an.Name, result.Filename);
                        TypeBuilder tb = mb.DefineType(string.Format("rLang.Execution.t{0}", an.Name), TypeAttributes.Public | TypeAttributes.Class);
                        MethodBuilder fb = tb.DefineMethod("Exec", MethodAttributes.Public | MethodAttributes.Static,
                            typeof(object), new Type[] { typeof(ExecutionContext) });

                        l.CompileToMethod(fb);
                        tb.CreateType();

                        result.Assembly = ab;

                    }

                }

            }

            return result;

        }

        private object CreateObject(object obj, SymbolTable symbolTable) {
            GOLD.Reduction reduction = obj as GOLD.Reduction;
            GOLD.Token token = obj as GOLD.Token;
            if (reduction != null) return CreateObjectFromReduction(reduction, symbolTable);
            if (token != null) return CreateObjectFromToken(token, symbolTable);

            throw new ArgumentException("The parameter 'obj' must be an GOLD.Reduction or a GOLD.Token");
        }

        private object GetTerminal(object obj, SymbolIndex type) {
            var token = obj as GOLD.Token;
            if (token != null) {
                var position = token.Position();
                if (!(token.Data is GOLD.Reduction)) {
                    switch (type) {
                        case SymbolIndex.Identifier:
                            return token.Data.ToString();
                        case SymbolIndex.Number:

                            string defStr = token.Data.ToString();

                            if (defStr[0] == '.') defStr = "0" + defStr;

                            try {
                                //will never receive a ',' in place of a '.' but...
                                return Double.Parse(defStr.Replace(',', '.'), System.Globalization.CultureInfo.InvariantCulture.NumberFormat);
                            } catch {
                                throw new LexicalErrorException(
                                    new LexicalError(position.Line, position.Column, token.Data.ToString())
                                );
                            }

                        case SymbolIndex.Stringliteral:
                            string defStrLit = token.Data.ToString();
                            return defStrLit.Substring(1, defStrLit.Length - 2);
                        default:
                            return null;
                    }


                }
                throw new LexicalErrorException(
                    new LexicalError(position.Line, position.Column, token.Data.ToString())
                );
            }
            throw new LexicalErrorException(
                new LexicalError(0, 0, token.Data.ToString())
            );
        }

        private object CreateObjectFromToken(GOLD.Token token, SymbolTable symbolTable) {

            var position = token.Position();
            this.lastLine = position.Line;
            this.lastColumn = position.Column;

            if (token.Data is GOLD.Reduction)
                return CreateObjectFromReduction(token.Data as GOLD.Reduction, symbolTable);
            else {
                throw new LexicalErrorException(
                    new LexicalError(position.Line, position.Column, token.Data.ToString())
                );
            }
        }

        private object CreateObjectFromReduction(GOLD.Reduction reduction, SymbolTable symbolTable) {
            object result = null;

            switch ((ProductionIndex)reduction.Parent.TableIndex()) {

                case ProductionIndex.Program:
                    // <Program> ::= <AssignList>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Program_Eq:
                    // <Program> ::= '=' <Bool Exp>
                    return CreateObject(reduction[1], symbolTable);

                case ProductionIndex.Assignlist:
                    // <AssignList> ::= <AssignList> <Assign Exp>
                    AssignExpression aExpression = (AssignExpression)CreateObject(reduction[0], symbolTable);

                    rLangExpression aNext = aExpression.Next;
                    if (aNext != null) {
                        while (aNext.Next != null)
                            aNext = aNext.Next;
                    }

                    if (aNext == null) aNext = aExpression;

                    aNext.Next = (AssignExpression)CreateObject(reduction[1], symbolTable);
                    return aExpression;

                case ProductionIndex.Assignlist2:
                    // <AssignList> ::= <Assign Exp>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Assignexp_Eq_Lbrace_Rbrace:
                    // <Assign Exp> ::= <IdentExpression> '=' '{' <Bool Exp> '}'
                    SymbolTable localSymbolTable = symbolTable.CreateLocalSymbolTable();
                    return new AssignExpression(
                        localSymbolTable.GetSymbol((string)CreateObject(reduction[0], localSymbolTable),
                            IdentifierSymbolType.Variable, this.lastLine, this.lastColumn),
                        (rLangExpression)CreateObject(reduction[3], localSymbolTable),
                        localSymbolTable
                    );
                case ProductionIndex.Assignexp_At_Eq_Lbrace_Rbrace:
                    // <Assign Exp> ::= '@' <IdentExpression> '=' '{' <Bool Exp> '}'
                    localSymbolTable = symbolTable.CreateLocalSymbolTable();
                    return new AssignExpression(
                            localSymbolTable.GetSymbol((string)CreateObject(reduction[1], localSymbolTable),
                                IdentifierSymbolType.GlobalVariable, this.lastLine, this.lastColumn),
                            (rLangExpression)CreateObject(reduction[4], localSymbolTable),
                            localSymbolTable
                        );

                case ProductionIndex.Assignexp_Dollardollar_Eq_Lbrace_Rbrace:
                    // <Assign Exp> ::= '$$' <IdentExpression> '=' '{' <Bool Exp> '}'
                    localSymbolTable = symbolTable.CreateLocalSymbolTable();
                    return new AssignExpression(
                            localSymbolTable.GetSymbol((string)CreateObject(reduction[1], localSymbolTable),
                                IdentifierSymbolType.GlobalVariable, this.lastLine, this.lastColumn),
                            (rLangExpression)CreateObject(reduction[4], localSymbolTable),
                            localSymbolTable
                        );

                case ProductionIndex.Assignexp_Dollar_Eq_Lbrace_Rbrace:
                    // <Assign Exp> ::= '$' <IdentExpression> '=' '{' <Bool Exp> '}'
                    localSymbolTable = symbolTable.CreateLocalSymbolTable();
                    return new AssignExpression(
                            localSymbolTable.GetSymbol((string)CreateObject(reduction[1], localSymbolTable),
                                IdentifierSymbolType.CellVariable, this.lastLine, this.lastColumn),
                            (rLangExpression)CreateObject(reduction[4], localSymbolTable),
                            localSymbolTable
                        );

                case ProductionIndex.Assignexp_Dollar_Lbracket_Colon_Rbracket_Eq_Lbrace_Rbrace:                 
                // <Assign Exp> ::= '$' <IdentExpression> '[' <ColReference> ':' <ColReference> ']' '=' '{' <Bool Exp> '}'
                    localSymbolTable = symbolTable.CreateLocalSymbolTable();

                    int rangeStart = (int)(Double)GetTerminal(reduction[3], SymbolIndex.Number);
                    int rangeEnd = (int)(Double)GetTerminal(reduction[5], SymbolIndex.Number);

                    var identDef = localSymbolTable.GetSymbol((string)CreateObject(reduction[1], localSymbolTable),
                                    rangeStart, rangeEnd, this.lastLine, this.lastColumn);

                    return new AssignExpression(
                        identDef,
                        (rLangExpression)CreateObject(reduction[9], localSymbolTable),
                        localSymbolTable
                    );

				case ProductionIndex.Assignexp_Dollar_Lbracket_Rbracket_Eq_Lbrace_Rbrace:                 
                // <Assign Exp> ::= '$' <IdentExpression> '[' <ColReference> ']' '=' '{' <Bool Exp> '}'
                    localSymbolTable = symbolTable.CreateLocalSymbolTable();

                    identDef = localSymbolTable.GetSymbol((string)CreateObject(reduction[1], localSymbolTable), IdentifierSymbolType.CellVariable,
                                    this.lastLine, this.lastColumn);

                    identDef.Row = (int)(Double)GetTerminal(reduction[3], SymbolIndex.Number); ;

                    return new AssignExpression(
                        identDef,
                        (rLangExpression)CreateObject(reduction[7], localSymbolTable),
                        localSymbolTable
                    );

                case ProductionIndex.Args_Comma:
                    // <Args> ::= <Args> ',' <Bool Exp>
                    List<rLangExpression> argsList = (List<rLangExpression>)CreateObject(reduction[0], symbolTable);
                    argsList.Add((rLangExpression)CreateObject(reduction[2], symbolTable));
                    return argsList;

                case ProductionIndex.Args:
                    // <Args> ::= <Bool Exp>
                    argsList = new List<rLangExpression>();
                    argsList.Add((rLangExpression)CreateObject(reduction[0], symbolTable));
                    return argsList;

                case ProductionIndex.Boolexp_And:
                    // <Bool Exp> ::= <Bool Exp> AND <Expression>
                    return new BooleanExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        BooleanOperator.AND
                    );

                case ProductionIndex.Boolexp_Or:
                    // <Bool Exp> ::= <Bool Exp> OR <Expression>
                    return new BooleanExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        BooleanOperator.OR
                    );

                case ProductionIndex.Boolexp_And_Lparen_Rparen:
                    // <Bool Exp> ::= AND '(' <Args> ')'
                    return new BooleanExpression(
                        (List<rLangExpression>)CreateObject(reduction[2], symbolTable),
                        BooleanOperator.AND
                    );

                case ProductionIndex.Boolexp_Or_Lparen_Rparen:
                    // <Bool Exp> ::= OR '(' <Args> ')'
                    return new BooleanExpression(
                        (List<rLangExpression>)CreateObject(reduction[2], symbolTable),
                        BooleanOperator.OR
                    );

                case ProductionIndex.Boolexp_Not:
                    // <Bool Exp> ::= NOT <Expression>
                    return new BooleanExpression(
                        (rLangExpression)CreateObject(reduction[1], symbolTable), null,
                        BooleanOperator.NOT
                    );

                case ProductionIndex.Boolexp:
                    // <Bool Exp> ::= <Expression>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Expression_Gt:
                    // <Expression> ::= <Expression> '>' <Add Exp>
                    return new ComparisonExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        ComparisonOperator.GT
                    );

                case ProductionIndex.Expression_Lt:
                    // <Expression> ::= <Expression> '<' <Add Exp>
                    return new ComparisonExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        ComparisonOperator.LT
                    );

                case ProductionIndex.Expression_Lteq:
                    // <Expression> ::= <Expression> '<=' <Add Exp>
                    return new ComparisonExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        ComparisonOperator.LTEQ
                    );

                case ProductionIndex.Expression_Gteq:
                    // <Expression> ::= <Expression> '>=' <Add Exp>
                    return new ComparisonExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        ComparisonOperator.GTEQ
                    );

                case ProductionIndex.Expression_Eq:
                    // <Expression> ::= <Expression> '=' <Add Exp>
                    return new ComparisonExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        ComparisonOperator.EQ
                    );

                case ProductionIndex.Expression_Ltgt:
                    // <Expression> ::= <Expression> '<>' <Add Exp>
                    return new ComparisonExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        ComparisonOperator.NEQ
                    );

                case ProductionIndex.Expression:
                    // <Expression> ::= <Add Exp>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Addexp_Plus:
                    // <Add Exp> ::= <Add Exp> '+' <Mult Exp>
                    return new MathExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        MathOperator.ADD
                    );

                case ProductionIndex.Addexp_Minus:
                    // <Add Exp> ::= <Add Exp> '-' <Mult Exp>
                    return new MathExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        MathOperator.SUBTR
                    );

                case ProductionIndex.Addexp_Amp:
                    // <Add Exp> ::= <Add Exp> '&' <Mult Exp>
                    return new MathExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        MathOperator.CONCATENATE
                    );

                case ProductionIndex.Addexp:
                    // <Add Exp> ::= <Mult Exp>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Multexp_Times:
                    // <Mult Exp> ::= <Mult Exp> '*' <Pow Exp>
                    return new MathExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        MathOperator.MULT
                    );

                case ProductionIndex.Multexp_Div:
                    // <Mult Exp> ::= <Mult Exp> '/' <Pow Exp>
                    return new MathExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        MathOperator.DIVD
                    );

                case ProductionIndex.Multexp:
                    // <Mult Exp> ::= <Pow Exp>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Powexp_Caret:
                    // <Pow Exp> ::= <Pow Exp> '^' <Percent Exp>
                    return new MathExpression(
                        (rLangExpression)CreateObject(reduction[0], symbolTable),
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        MathOperator.POW
                    );

                case ProductionIndex.Powexp:
                    // <Pow Exp> ::= <Percent Exp>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Percentexp_Percent:
                    // <Percent Exp> ::= <Negate Exp> '%'
                    return new PercentExpression((rLangExpression)CreateObject(reduction[0], symbolTable));

                case ProductionIndex.Percentexp:
                    // <Percent Exp> ::= <Negate Exp>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Negateexp_Minus:
                    // <Negate Exp> ::= '-' <Value>
                    return new NegateExpression((rLangExpression)CreateObject(reduction[1], symbolTable));

                case ProductionIndex.Negateexp:
                    // <Negate Exp> ::= <Value>
                    return CreateObject(reduction[0], symbolTable);

                case ProductionIndex.Value_Number:
                    // <Value> ::= Number
                    return new NumberExpression((Double)GetTerminal(reduction[0], SymbolIndex.Number));

                case ProductionIndex.Value_If_Lparen_Rparen_Then_End:                 
                // <Value> ::= IF '(' <Bool Exp> ')' THEN <Bool Exp> END
                    return new ConditionalExpression(
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        (rLangExpression)CreateObject(reduction[5], symbolTable),
                        null, false
                    );

                case ProductionIndex.Value_If_Lparen_Rparen_Then_Else_End:                 
                // <Value> ::= IF '(' <Bool Exp> ')' THEN <Bool Exp> ELSE <Bool Exp> END
                    return new ConditionalExpression(
                        (rLangExpression)CreateObject(reduction[2], symbolTable),
                        (rLangExpression)CreateObject(reduction[5], symbolTable),
                        (rLangExpression)CreateObject(reduction[7], symbolTable),
                        false
                    );

                case ProductionIndex.Value_If_Lparen_Rparen:
                    // <Value> ::= IF '(' <Args> ')'
                    return new ConditionalExpression((List<rLangExpression>)CreateObject(reduction[2], symbolTable));

                case ProductionIndex.Value_Lparen_Rparen:
                    // <Value> ::= <IdentExpression> '(' <Args> ')'
                    return new FunctionExpression(
                        symbolTable.GetSymbol((string)CreateObject(reduction[0], symbolTable),
                            IdentifierSymbolType.Function, this.lastLine, this.lastColumn),
                        (List<rLangExpression>)CreateObject(reduction[2], symbolTable));

                case ProductionIndex.Value_Lparen_Rparen2:
                    // <Value> ::= <IdentExpression> '(' ')'
                    return new FunctionExpression(
                        symbolTable.GetSymbol((string)CreateObject(reduction[0], symbolTable),
                            IdentifierSymbolType.Function, this.lastLine, this.lastColumn),
                        new List<rLangExpression>()
                    );

                case ProductionIndex.Value_Dollar_Lbracket_Rbracket_Colon_Dollar_Lbracket_Rbracket:                 
                // <Value> ::= '$' <IdentExpression> '[' <ColReference> ']' ':' '$' <IdentExpression> '[' <ColReference> ']'

                    var ident1 = (string)CreateObject(reduction[1], symbolTable);
                    var ident2 = (string)GetTerminal(reduction[7], SymbolIndex.Identifier);

                    rangeStart = (int)(Double)GetTerminal(reduction[3], SymbolIndex.Number);
                    rangeEnd = (int)(Double)GetTerminal(reduction[9], SymbolIndex.Number);

                    identDef = symbolTable.GetSymbol(ident1, rangeStart, ident2, rangeEnd, this.lastLine, this.lastColumn);

                    return new IdentifierExpression(identDef);

                case ProductionIndex.Value_Dollar_Lbracket_Colon_Rbracket:                 
                // <Value> ::= '$' <IdentExpression> '[' <ColReference> ':' <ColReference> ']'

                    rangeStart = (int)(Double)GetTerminal(reduction[3], SymbolIndex.Number);
                    rangeEnd = (int)(Double)GetTerminal(reduction[5], SymbolIndex.Number);

                    identDef = symbolTable.GetSymbol((string)CreateObject(reduction[1], symbolTable),
                            rangeStart, rangeEnd, this.lastLine, this.lastColumn);


                    return new IdentifierExpression(identDef);

                case ProductionIndex.Value_Dollar_Lbracket_Rbracket:                 
                // <Value> ::= '$' <IdentExpression> '[' <ColReference> ']'

                    identDef = symbolTable.GetSymbol((string)CreateObject(reduction[1], symbolTable), IdentifierSymbolType.CellVariable,
                            this.lastLine, this.lastColumn);

                    identDef.Row = (int)(Double)GetTerminal(reduction[3], SymbolIndex.Number);

                    return new IdentifierExpression(identDef);

                case ProductionIndex.Value_Lbracket_Rbracket_Colon_Identifier_Lbracket_Rbracket:                 
                // <Value> ::= <IdentExpression> '[' <ColReference> ']' ':' Identifier '[' <ColReference> ']'
                    ident1 = (string)CreateObject(reduction[0], symbolTable);
                    ident2 = (string)GetTerminal(reduction[5], SymbolIndex.Identifier);

                    rangeStart = (int)(Double)GetTerminal(reduction[2], SymbolIndex.Number);
                    rangeEnd = (int)(Double)GetTerminal(reduction[7], SymbolIndex.Number);

                    identDef = symbolTable.GetSymbol(ident1, rangeStart, ident2, rangeEnd, this.lastLine, this.lastColumn);

                    return new IdentifierExpression(identDef);

                case ProductionIndex.Value_Lbracket_Colon_Rbracket:                 
                // <Value> ::= <IdentExpression> '[' <ColReference> ':' <ColReference> ']'
                    rangeStart = (int)(Double)GetTerminal(reduction[2], SymbolIndex.Number);
                    rangeEnd = (int)(Double)GetTerminal(reduction[4], SymbolIndex.Number);

                    identDef = symbolTable.GetSymbol((string)CreateObject(reduction[0], symbolTable),
                            rangeStart, rangeEnd, this.lastLine, this.lastColumn);


                    return new IdentifierExpression(identDef);

                case ProductionIndex.Value_Lbracket_Rbracket:                 
                // <Value> ::= <IdentExpression> '[' <ColReference> ']'

                    identDef = symbolTable.GetSymbol((string)CreateObject(reduction[0], symbolTable), IdentifierSymbolType.CellVariable,
                                    this.lastLine, this.lastColumn);

                    identDef.Row = (int)(Double)GetTerminal(reduction[2], SymbolIndex.Number);

                    return new IdentifierExpression(identDef);

                case ProductionIndex.Value_Dollar_Identifier_Colon_Dollar_Identifier:
                    // <Value> ::= '$' Identifier ':' '$' Identifier

                    var identRange1 = TryGetIdentifierRange((string)GetTerminal(reduction[1], SymbolIndex.Identifier));
                    var identRange2 = TryGetIdentifierRange((string)GetTerminal(reduction[4], SymbolIndex.Identifier));

                    ident1 = identRange1.Key;
                    ident2 = identRange2.Key;

                    rangeStart = identRange1.Value;
                    rangeEnd = identRange2.Value;

                    identDef = symbolTable.GetSymbol(ident1, rangeStart, ident2, rangeEnd, this.lastLine, this.lastColumn);

                    return new IdentifierExpression(identDef);

                case ProductionIndex.Value_Identifier_Colon_Identifier:
                    // <Value> ::= Identifier ':' Identifier
                    identRange1 = TryGetIdentifierRange((string)GetTerminal(reduction[0], SymbolIndex.Identifier));
                    identRange2 = TryGetIdentifierRange((string)GetTerminal(reduction[2], SymbolIndex.Identifier));

                    ident1 = identRange1.Key;
                    ident2 = identRange2.Key;

                    rangeStart = identRange1.Value;
                    rangeEnd = identRange2.Value;

                    identDef = symbolTable.GetSymbol(ident1, rangeStart, ident2, rangeEnd, this.lastLine, this.lastColumn);

                    return new IdentifierExpression(identDef);

				case ProductionIndex.Value_Dollar_Identifier_Dollar_Number_Colon_Dollar_Identifier_Dollar_Number:                 
                // <Value> ::= '$' Identifier '$' Number ':' '$' Identifier '$' Number
                break;

                case ProductionIndex.Value_Dollar:
                    // <Value> ::= '$' <IdentExpression>
                    return new IdentifierExpression(
                        symbolTable.GetSymbol((string)CreateObject(reduction[1], symbolTable),
                            IdentifierSymbolType.CellVariable, this.lastLine, this.lastColumn));

                case ProductionIndex.Value_Dollardollar:
                    // <Value> ::= '$$' <IdentExpression>
                    return new IdentifierExpression(
                        symbolTable.GetSymbol((string)CreateObject(reduction[1], symbolTable),
                            IdentifierSymbolType.GlobalVariable, this.lastLine, this.lastColumn));

                case ProductionIndex.Value_At:
                    // <Value> ::= '@' <IdentExpression>
                    return new IdentifierExpression(
                        symbolTable.GetSymbol((string)CreateObject(reduction[1], symbolTable),
                            IdentifierSymbolType.GlobalVariable, this.lastLine, this.lastColumn));

                case ProductionIndex.Value:
                    // <Value> ::= <IdentExpression>
                    return new IdentifierExpression(
                        symbolTable.GetSymbol((string)CreateObject(reduction[0], symbolTable), 
                            IdentifierSymbolType.Variable, this.lastLine, this.lastColumn));

                case ProductionIndex.Value_Stringliteral:
                    // <Value> ::= StringLiteral
                    return new StringExpression((string)GetTerminal(reduction[0], SymbolIndex.Stringliteral));

                case ProductionIndex.Value_Lparen_Rparen3:
                    // <Value> ::= '(' <Bool Exp> ')'
                    return new ParenthesesExpression((rLangExpression)CreateObject(reduction[1], symbolTable));

                case ProductionIndex.Identexpression_Identifier:
                    // <IdentExpression> ::= Identifier
                    return GetTerminal(reduction[0], SymbolIndex.Identifier);

				case ProductionIndex.Colreference_Number:                 
	                // <ColReference> ::= Number
	                break;
	
	            case ProductionIndex.Colreference_Minus_Number:                 
	                // <ColReference> ::= '-' Number
	                break;
	
	            case ProductionIndex.Colreference_Dollar_Number:                 
	                // <ColReference> ::= '$' Number
	                break;

            }  //switch

            return result;
        }

        public KeyValuePair<string, int> TryGetIdentifierRange(string ident) {

            if (ident == null || ident == string.Empty) throw new ArgumentException("identifier can't be empty");

            List<char> numChar = new List<char>(); ;
            int index = 0; 

            for (int i = ident.Length -1; i >= 0; i--) {
                char c = ident[i];
                if (char.IsDigit(c)) {
                    index = i;
                    numChar.Add(c);
                } else
                    break;
            }

            if (numChar.Count > 0) {
                numChar.Reverse();
                int num = int.Parse(new string(numChar.ToArray()));
                ident = ident.Remove(index);
                return new KeyValuePair<string, int>(ident, num);
            } else
                throw new ArgumentException(
                    "Identifier must contain a range i.e. [IdentNNN]"
                );
        }

    }; //MyParser

}
